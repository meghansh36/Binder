const {parse} = require('url')
const { BrowserWindow, session } = require('electron');
const axios = require('axios');
const qs = require('querystring');

/**
 * Authorizaton URL for Google
 */
const GOOGLE_AUTHORIZATION_URL = 'https://accounts.google.com/o/oauth2/v2/auth'

/**
 * Url for the proxy server
 */
const proxyUrl = 'https://binder-v1.herokuapp.com'

/**
 * Url for uniquely identifying and setting cookies for session persistence
 */
const cookieUrl = 'https://binder-v1.herokuapp.com'

/**
 * Function to initiate the login process
 */
async function login() {

    try {
        // get the secret from the proxy server
        const secret = await axios.get(`${proxyUrl}/getClientSecrets`);
        // login code generated by google to fetch tokens
        const code = await loginPopup(secret.data);
        console.log('sending request')

        // access and refresh tokens fetched from the proxy server. The tokens are encrypted adding another layer of security.
        const tokens = await axios.post(`${proxyUrl}/fetchAccessTokens`, {code});

        // setting access_token cookie. Expiration time is 1hr. 
        await session.defaultSession.cookies.set({
          url: `${cookieUrl}`,
          name: 'access_token',
          value: tokens.data.access_token,
          domain: '.binder-v1.herokuapp.com',
          path: '/',
          expirationDate: Number(Date.now())/1000 + 3600,
          httpOnly: true,
          secure: false
        });


        var aYearFromNow = new Date();
        aYearFromNow.setFullYear(aYearFromNow.getFullYear() + 1);

        // setting refresh token cookie. Expiration time is 1 year.
        await session.defaultSession.cookies.set({
          url: `${cookieUrl}`,
          name: 'refresh_token',
          value: tokens.data.refresh_token,
          domain: '.binder-v1.herokuapp.com',
          path: '/',
          expirationDate: Number(aYearFromNow.getTime())/1000,
          httpOnly: true,
          secure: false
        });
        await session.defaultSession.cookies.flushStore();
        console.log('flushed cookies')
        
    } catch (error) {
      console.log(error)
        throw new Error('login failed', error);
    }
}

async function logout() {
  try {
    await session.defaultSession.cookies.remove(`${cookieUrl}`, 'access_token');
    await session.defaultSession.cookies.remove(`${cookieUrl}`, 'refresh_token');
  } catch (error) {

    console.log(error);

    throw new Error('logout failed');
  }
}

/**
 * This function opens the popup window for google login and listens to various navigation events.
 * @param {string} secret : the secret key returned from proxy server
 */
async function loginPopup(secret) {
    return new Promise((resolve, reject) => {
        const authWindow = new BrowserWindow({
            width: 500,
            height: 600,
            show: true
        })

        const urlParams = {
            response_type: 'code',
            redirect_uri: secret.redirect_url,
            client_id: secret.id,
            scope: secret.scopes,
          }
        
        const authURL = `${GOOGLE_AUTHORIZATION_URL}?${qs.stringify(urlParams)}`

        authWindow.on('closed', () => {
            reject(new Error('window closed by user'));
          })
      
          authWindow.webContents.on('will-navigate', (event, url) => {
              console.log('will-navigate')
              handleNavigation(url)
          })
      
          authWindow.webContents.on('did-get-redirect-request', (event, oldUrl, newUrl) => {
            handleNavigation(newUrl)
          })
      
          // load google url for login
          authWindow.loadURL(authURL)


          /**
           * This function checks for successful login. If successful, close the popup window and send the code for fetching tokens
           * @param {string} url : redirected url
           */
          function handleNavigation (url) {
            const query = parse(url, true).query
            if (query) {
              if (query.error) {
                reject(new Error(`There was an error: ${query.error}`))
              } else if (query.code) {
                // Login is complete
                authWindow.removeAllListeners('closed')
                setImmediate(() => authWindow.close())
      
                // This is the authorization code we need to request tokens
                resolve(query.code)
              }
            }
          }


     })
}

/**
 * This function checks if a user is logged in already. This function runs on app startup
 */
async function checkLogin() {
  // fund if refresh_token cookie is present or not
  let cookie = await session.defaultSession.cookies.get({name: 'refresh_token', url:`${proxyUrl}`});
  // if present, user is logged in 
  if(cookie.length !== 0) {
    return true;
  } else {
    throw new Error('not logged in');
  }
}

/**
 * This function returns a token matching url and name
 * @param {string} name : name of the cookie
 * @param {string} url : url of the cookie
 */
async function getTokenCookie(name, url) {

  let cookie = await session.defaultSession.cookies.get({name, url});
  // if not found, return undefined
  if (cookie.length === 0)
    return undefined;
  else return cookie[0];
}

/**
 * This function checks if access_token is present or not. If not present, it calls the generate token function
 */
async function checkAndGenerateToken() {
  let foundAccessToken = await checkToken();

  if(!foundAccessToken) {
    await generateToken().catch(e => {
      throw e;
    })
  }
}

/**
 * Checks if access_token is present or not.
 */
async function checkToken() {
  let cookie = await getTokenCookie('access_token', cookieUrl)
  if(cookie) {
    return true;
  }
  return false;
}

/**
 * This function generates an access_token if it is expired.
 */
async function generateToken() {
  // fetch refresh_token
  let cookie = await getTokenCookie('refresh_token', cookieUrl)
  if(cookie) {

    try {
      // fetch access token from proxy server
      const newAccessToken = await axios.get(`${proxyUrl}/fetchNewAccessToken`, {
        headers: {Cookie: `refresh_token=${cookie.value};`}
      })
      
      // set the access token
      await session.defaultSession.cookies.set({
        url: `${cookieUrl}`,
        name: 'access_token',
        value: newAccessToken.data.access_token,
        domain: '.binder-v1.herokuapp.com',
        path: '/',
        expirationDate: Number(Date.now())/1000 + 3600,
        httpOnly: true,
        secure: false
      });
  
      await session.defaultSession.cookies.flushStore();
    } catch (error) {
      throw error;
    }
  } else {
    throw new Error('refresh token not found');
  }

}

module.exports = {
    login,
    checkLogin,
    getTokenCookie,
    proxyUrl,
    cookieUrl,
    checkAndGenerateToken,
    logout
}